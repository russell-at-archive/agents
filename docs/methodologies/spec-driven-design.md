# Spec-Driven Design (SDD)

Spec-Driven Design (SDD) is an engineering methodology where **structured specifications** serve as the primary source of truth and the authoritative "contract" for a system's implementation. It shifts the development focus from writing code to defining intent, requirements, and constraints in a format that can be validated, simulated, or used to generate implementation artifacts.

## Core Philosophy: "The Spec is the Source"

In traditional development, documentation is often a trailing artifact that quickly goes out of date. In SDD, the specification is **upstream** of the code:
- **Contract as Code:** The specification (e.g., OpenAPI, Protobuf, or a structured Markdown file) is version-controlled alongside the implementation.
- **Intent-First:** No implementation begins until the specification is validated for logical consistency and completeness.
- **Deterministic vs. Probabilistic Generation:** SDD allows for both deterministic code generation (using templates) and probabilistic generation (leveraging AI agents), provided they are anchored to the spec.

## The SDD Lifecycle (The "Core Loop")

Regardless of the tools used, the SDD workflow follows a rigorous four-phase cycle:

1.  **Define (Governance & Constraints):** Establish the "ground rules" or "constitution" of the project. This includes architectural patterns, security requirements, and technical standards that all future specs must obey.
2.  **Specify (Functional Intent):** Create a formal or semi-formal description of the feature. This focuses on **What** the system does (User Stories, Acceptance Criteria, Data Models) rather than **How** it is built.
3.  **Validate & Clarify (The Logic Gate):** The specification is audited for ambiguity, contradictions, or missing edge cases. In modern workflows, this is the "unit test for intent."
4.  **Execute (Implementation & Verification):** The implementation is derived from the spec. This phase includes generating code, tests, and documentation, followed by verification (TDD/BDD) to ensure the implementation 100% matches the specification.

## Implementation Levels

| Level | Name | Description |
| :--- | :--- | :--- |
| **Level 1** | **Spec-First** | The spec provides initial guidance and documentation but is not strictly enforced after coding begins. |
| **Level 2** | **Spec-Anchored** | The spec and code are maintained in lockstep. Changes to one must be reflected in the other via automated checks. |
| **Level 3** | **Spec-as-Source** | The specification is the *only* manual artifact. The code is a disposable, generated byproduct of the spec. |

## Universal Artifacts

| Artifact | Common Formats | Purpose |
| :--- | :--- | :--- |
| **Project Constitution** | Markdown, ADRs | Permanent project guardrails and architectural decisions. |
| **Data Contracts** | JSON Schema, Protobuf | Defines the shape and constraints of data at rest and in transit. |
| **Interface Specs** | OpenAPI, AsyncAPI, GraphQL | Defines the interaction points between system components. |
| **Functional Spec** | Structured Markdown, Gherkin | Human-readable requirements and acceptance criteria. |
| **Implementation Plan** | Tasks, Gantt, Dependency Graphs | The atomic breakdown of work required to satisfy the spec. |

## Why SDD is Critical for Modern Engineering

- **Scalability for AI:** AI agents perform significantly better when given a formal specification rather than a vague prompt. SDD provides the "guardrails" that prevent AI hallucinations.
- **Single Source of Truth:** Reduces the "documentation tax" by ensuring that the spec is the most accurate reflection of the system's intent.
- **Improved Integration:** By defining contracts before implementation, separate teams (e.g., Frontend and Backend) can work in parallel with zero friction.
- **Auditability & Traceability:** Every line of code can be traced back to a specific requirement in the validated specification.
